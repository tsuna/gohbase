// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ZooKeeper.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SplitLogTask_State int32

const (
	SplitLogTask_UNASSIGNED SplitLogTask_State = 0
	SplitLogTask_OWNED      SplitLogTask_State = 1
	SplitLogTask_RESIGNED   SplitLogTask_State = 2
	SplitLogTask_DONE       SplitLogTask_State = 3
	SplitLogTask_ERR        SplitLogTask_State = 4
)

var SplitLogTask_State_name = map[int32]string{
	0: "UNASSIGNED",
	1: "OWNED",
	2: "RESIGNED",
	3: "DONE",
	4: "ERR",
}
var SplitLogTask_State_value = map[string]int32{
	"UNASSIGNED": 0,
	"OWNED":      1,
	"RESIGNED":   2,
	"DONE":       3,
	"ERR":        4,
}

func (x SplitLogTask_State) Enum() *SplitLogTask_State {
	p := new(SplitLogTask_State)
	*p = x
	return p
}
func (x SplitLogTask_State) String() string {
	return proto.EnumName(SplitLogTask_State_name, int32(x))
}
func (x *SplitLogTask_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SplitLogTask_State_value, data, "SplitLogTask_State")
	if err != nil {
		return err
	}
	*x = SplitLogTask_State(value)
	return nil
}
func (SplitLogTask_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor19, []int{4, 0} }

type SplitLogTask_RecoveryMode int32

const (
	SplitLogTask_UNKNOWN       SplitLogTask_RecoveryMode = 0
	SplitLogTask_LOG_SPLITTING SplitLogTask_RecoveryMode = 1
	SplitLogTask_LOG_REPLAY    SplitLogTask_RecoveryMode = 2
)

var SplitLogTask_RecoveryMode_name = map[int32]string{
	0: "UNKNOWN",
	1: "LOG_SPLITTING",
	2: "LOG_REPLAY",
}
var SplitLogTask_RecoveryMode_value = map[string]int32{
	"UNKNOWN":       0,
	"LOG_SPLITTING": 1,
	"LOG_REPLAY":    2,
}

func (x SplitLogTask_RecoveryMode) Enum() *SplitLogTask_RecoveryMode {
	p := new(SplitLogTask_RecoveryMode)
	*p = x
	return p
}
func (x SplitLogTask_RecoveryMode) String() string {
	return proto.EnumName(SplitLogTask_RecoveryMode_name, int32(x))
}
func (x *SplitLogTask_RecoveryMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SplitLogTask_RecoveryMode_value, data, "SplitLogTask_RecoveryMode")
	if err != nil {
		return err
	}
	*x = SplitLogTask_RecoveryMode(value)
	return nil
}
func (SplitLogTask_RecoveryMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor19, []int{4, 1}
}

// Table's current state
type Table_State int32

const (
	Table_ENABLED   Table_State = 0
	Table_DISABLED  Table_State = 1
	Table_DISABLING Table_State = 2
	Table_ENABLING  Table_State = 3
)

var Table_State_name = map[int32]string{
	0: "ENABLED",
	1: "DISABLED",
	2: "DISABLING",
	3: "ENABLING",
}
var Table_State_value = map[string]int32{
	"ENABLED":   0,
	"DISABLED":  1,
	"DISABLING": 2,
	"ENABLING":  3,
}

func (x Table_State) Enum() *Table_State {
	p := new(Table_State)
	*p = x
	return p
}
func (x Table_State) String() string {
	return proto.EnumName(Table_State_name, int32(x))
}
func (x *Table_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Table_State_value, data, "Table_State")
	if err != nil {
		return err
	}
	*x = Table_State(value)
	return nil
}
func (Table_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor19, []int{5, 0} }

type ReplicationState_State int32

const (
	ReplicationState_ENABLED  ReplicationState_State = 0
	ReplicationState_DISABLED ReplicationState_State = 1
)

var ReplicationState_State_name = map[int32]string{
	0: "ENABLED",
	1: "DISABLED",
}
var ReplicationState_State_value = map[string]int32{
	"ENABLED":  0,
	"DISABLED": 1,
}

func (x ReplicationState_State) Enum() *ReplicationState_State {
	p := new(ReplicationState_State)
	*p = x
	return p
}
func (x ReplicationState_State) String() string {
	return proto.EnumName(ReplicationState_State_name, int32(x))
}
func (x *ReplicationState_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReplicationState_State_value, data, "ReplicationState_State")
	if err != nil {
		return err
	}
	*x = ReplicationState_State(value)
	return nil
}
func (ReplicationState_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor19, []int{7, 0} }

// *
// Content of the meta-region-server znode.
type MetaRegionServer struct {
	// The ServerName hosting the meta region currently, or destination server,
	// if meta region is in transition.
	Server *ServerName `protobuf:"bytes,1,req,name=server" json:"server,omitempty"`
	// The major version of the rpc the server speaks.  This is used so that
	// clients connecting to the cluster can have prior knowledge of what version
	// to send to a RegionServer.  AsyncHBase will use this to detect versions.
	RpcVersion *uint32 `protobuf:"varint,2,opt,name=rpc_version,json=rpcVersion" json:"rpc_version,omitempty"`
	// State of the region transition. OPEN means fully operational 'hbase:meta'
	State            *RegionState_State `protobuf:"varint,3,opt,name=state,enum=pb.RegionState_State" json:"state,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *MetaRegionServer) Reset()                    { *m = MetaRegionServer{} }
func (m *MetaRegionServer) String() string            { return proto.CompactTextString(m) }
func (*MetaRegionServer) ProtoMessage()               {}
func (*MetaRegionServer) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{0} }

func (m *MetaRegionServer) GetServer() *ServerName {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *MetaRegionServer) GetRpcVersion() uint32 {
	if m != nil && m.RpcVersion != nil {
		return *m.RpcVersion
	}
	return 0
}

func (m *MetaRegionServer) GetState() RegionState_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return RegionState_OFFLINE
}

// *
// Content of the master znode.
type Master struct {
	// The ServerName of the current Master
	Master *ServerName `protobuf:"bytes,1,req,name=master" json:"master,omitempty"`
	// Major RPC version so that clients can know what version the master can accept.
	RpcVersion       *uint32 `protobuf:"varint,2,opt,name=rpc_version,json=rpcVersion" json:"rpc_version,omitempty"`
	InfoPort         *uint32 `protobuf:"varint,3,opt,name=info_port,json=infoPort" json:"info_port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Master) Reset()                    { *m = Master{} }
func (m *Master) String() string            { return proto.CompactTextString(m) }
func (*Master) ProtoMessage()               {}
func (*Master) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{1} }

func (m *Master) GetMaster() *ServerName {
	if m != nil {
		return m.Master
	}
	return nil
}

func (m *Master) GetRpcVersion() uint32 {
	if m != nil && m.RpcVersion != nil {
		return *m.RpcVersion
	}
	return 0
}

func (m *Master) GetInfoPort() uint32 {
	if m != nil && m.InfoPort != nil {
		return *m.InfoPort
	}
	return 0
}

// *
// Content of the '/hbase/running', cluster state, znode.
type ClusterUp struct {
	// If this znode is present, cluster is up.  Currently
	// the data is cluster start_date.
	StartDate        *string `protobuf:"bytes,1,req,name=start_date,json=startDate" json:"start_date,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ClusterUp) Reset()                    { *m = ClusterUp{} }
func (m *ClusterUp) String() string            { return proto.CompactTextString(m) }
func (*ClusterUp) ProtoMessage()               {}
func (*ClusterUp) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{2} }

func (m *ClusterUp) GetStartDate() string {
	if m != nil && m.StartDate != nil {
		return *m.StartDate
	}
	return ""
}

// *
// What we write under unassigned up in zookeeper as a region moves through
// open/close, etc., regions.  Details a region in transition.
type RegionTransition struct {
	// Code for EventType gotten by doing o.a.h.h.EventHandler.EventType.getCode()
	EventTypeCode *uint32 `protobuf:"varint,1,req,name=event_type_code,json=eventTypeCode" json:"event_type_code,omitempty"`
	// Full regionname in bytes
	RegionName []byte  `protobuf:"bytes,2,req,name=region_name,json=regionName" json:"region_name,omitempty"`
	CreateTime *uint64 `protobuf:"varint,3,req,name=create_time,json=createTime" json:"create_time,omitempty"`
	// The region server where the transition will happen or is happening
	ServerName       *ServerName `protobuf:"bytes,4,req,name=server_name,json=serverName" json:"server_name,omitempty"`
	Payload          []byte      `protobuf:"bytes,5,opt,name=payload" json:"payload,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *RegionTransition) Reset()                    { *m = RegionTransition{} }
func (m *RegionTransition) String() string            { return proto.CompactTextString(m) }
func (*RegionTransition) ProtoMessage()               {}
func (*RegionTransition) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{3} }

func (m *RegionTransition) GetEventTypeCode() uint32 {
	if m != nil && m.EventTypeCode != nil {
		return *m.EventTypeCode
	}
	return 0
}

func (m *RegionTransition) GetRegionName() []byte {
	if m != nil {
		return m.RegionName
	}
	return nil
}

func (m *RegionTransition) GetCreateTime() uint64 {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return 0
}

func (m *RegionTransition) GetServerName() *ServerName {
	if m != nil {
		return m.ServerName
	}
	return nil
}

func (m *RegionTransition) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// *
// WAL SplitLog directory znodes have this for content.  Used doing distributed
// WAL splitting.  Holds current state and name of server that originated split.
type SplitLogTask struct {
	State            *SplitLogTask_State        `protobuf:"varint,1,req,name=state,enum=pb.SplitLogTask_State" json:"state,omitempty"`
	ServerName       *ServerName                `protobuf:"bytes,2,req,name=server_name,json=serverName" json:"server_name,omitempty"`
	Mode             *SplitLogTask_RecoveryMode `protobuf:"varint,3,opt,name=mode,enum=pb.SplitLogTask_RecoveryMode,def=0" json:"mode,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *SplitLogTask) Reset()                    { *m = SplitLogTask{} }
func (m *SplitLogTask) String() string            { return proto.CompactTextString(m) }
func (*SplitLogTask) ProtoMessage()               {}
func (*SplitLogTask) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{4} }

const Default_SplitLogTask_Mode SplitLogTask_RecoveryMode = SplitLogTask_UNKNOWN

func (m *SplitLogTask) GetState() SplitLogTask_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return SplitLogTask_UNASSIGNED
}

func (m *SplitLogTask) GetServerName() *ServerName {
	if m != nil {
		return m.ServerName
	}
	return nil
}

func (m *SplitLogTask) GetMode() SplitLogTask_RecoveryMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return Default_SplitLogTask_Mode
}

// *
// The znode that holds state of table.
type Table struct {
	// This is the table's state.  If no znode for a table,
	// its state is presumed enabled.  See o.a.h.h.zookeeper.ZKTable class
	// for more.
	State            *Table_State `protobuf:"varint,1,req,name=state,enum=pb.Table_State,def=0" json:"state,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Table) Reset()                    { *m = Table{} }
func (m *Table) String() string            { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()               {}
func (*Table) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{5} }

const Default_Table_State Table_State = Table_ENABLED

func (m *Table) GetState() Table_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return Default_Table_State
}

// *
// Used by replication. Holds a replication peer key.
type ReplicationPeer struct {
	// clusterkey is the concatenation of the slave cluster's
	// hbase.zookeeper.quorum:hbase.zookeeper.property.clientPort:zookeeper.znode.parent
	Clusterkey              *string           `protobuf:"bytes,1,req,name=clusterkey" json:"clusterkey,omitempty"`
	ReplicationEndpointImpl *string           `protobuf:"bytes,2,opt,name=replicationEndpointImpl" json:"replicationEndpointImpl,omitempty"`
	Data                    []*BytesBytesPair `protobuf:"bytes,3,rep,name=data" json:"data,omitempty"`
	Configuration           []*NameStringPair `protobuf:"bytes,4,rep,name=configuration" json:"configuration,omitempty"`
	XXX_unrecognized        []byte            `json:"-"`
}

func (m *ReplicationPeer) Reset()                    { *m = ReplicationPeer{} }
func (m *ReplicationPeer) String() string            { return proto.CompactTextString(m) }
func (*ReplicationPeer) ProtoMessage()               {}
func (*ReplicationPeer) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{6} }

func (m *ReplicationPeer) GetClusterkey() string {
	if m != nil && m.Clusterkey != nil {
		return *m.Clusterkey
	}
	return ""
}

func (m *ReplicationPeer) GetReplicationEndpointImpl() string {
	if m != nil && m.ReplicationEndpointImpl != nil {
		return *m.ReplicationEndpointImpl
	}
	return ""
}

func (m *ReplicationPeer) GetData() []*BytesBytesPair {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ReplicationPeer) GetConfiguration() []*NameStringPair {
	if m != nil {
		return m.Configuration
	}
	return nil
}

// *
// Used by replication. Holds whether enabled or disabled
type ReplicationState struct {
	State            *ReplicationState_State `protobuf:"varint,1,req,name=state,enum=pb.ReplicationState_State" json:"state,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *ReplicationState) Reset()                    { *m = ReplicationState{} }
func (m *ReplicationState) String() string            { return proto.CompactTextString(m) }
func (*ReplicationState) ProtoMessage()               {}
func (*ReplicationState) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{7} }

func (m *ReplicationState) GetState() ReplicationState_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ReplicationState_ENABLED
}

// *
// Used by replication. Holds the current position in an WAL file.
type ReplicationHLogPosition struct {
	Position         *int64 `protobuf:"varint,1,req,name=position" json:"position,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReplicationHLogPosition) Reset()                    { *m = ReplicationHLogPosition{} }
func (m *ReplicationHLogPosition) String() string            { return proto.CompactTextString(m) }
func (*ReplicationHLogPosition) ProtoMessage()               {}
func (*ReplicationHLogPosition) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{8} }

func (m *ReplicationHLogPosition) GetPosition() int64 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return 0
}

// *
// Used by replication. Used to lock a region server during failover.
type ReplicationLock struct {
	LockOwner        *string `protobuf:"bytes,1,req,name=lock_owner,json=lockOwner" json:"lock_owner,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ReplicationLock) Reset()                    { *m = ReplicationLock{} }
func (m *ReplicationLock) String() string            { return proto.CompactTextString(m) }
func (*ReplicationLock) ProtoMessage()               {}
func (*ReplicationLock) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{9} }

func (m *ReplicationLock) GetLockOwner() string {
	if m != nil && m.LockOwner != nil {
		return *m.LockOwner
	}
	return ""
}

// *
// Metadata associated with a table lock in zookeeper
type TableLock struct {
	TableName        *TableName  `protobuf:"bytes,1,opt,name=table_name,json=tableName" json:"table_name,omitempty"`
	LockOwner        *ServerName `protobuf:"bytes,2,opt,name=lock_owner,json=lockOwner" json:"lock_owner,omitempty"`
	ThreadId         *int64      `protobuf:"varint,3,opt,name=thread_id,json=threadId" json:"thread_id,omitempty"`
	IsShared         *bool       `protobuf:"varint,4,opt,name=is_shared,json=isShared" json:"is_shared,omitempty"`
	Purpose          *string     `protobuf:"bytes,5,opt,name=purpose" json:"purpose,omitempty"`
	CreateTime       *int64      `protobuf:"varint,6,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TableLock) Reset()                    { *m = TableLock{} }
func (m *TableLock) String() string            { return proto.CompactTextString(m) }
func (*TableLock) ProtoMessage()               {}
func (*TableLock) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{10} }

func (m *TableLock) GetTableName() *TableName {
	if m != nil {
		return m.TableName
	}
	return nil
}

func (m *TableLock) GetLockOwner() *ServerName {
	if m != nil {
		return m.LockOwner
	}
	return nil
}

func (m *TableLock) GetThreadId() int64 {
	if m != nil && m.ThreadId != nil {
		return *m.ThreadId
	}
	return 0
}

func (m *TableLock) GetIsShared() bool {
	if m != nil && m.IsShared != nil {
		return *m.IsShared
	}
	return false
}

func (m *TableLock) GetPurpose() string {
	if m != nil && m.Purpose != nil {
		return *m.Purpose
	}
	return ""
}

func (m *TableLock) GetCreateTime() int64 {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return 0
}

// *
// State of the switch.
type SwitchState struct {
	Enabled          *bool  `protobuf:"varint,1,opt,name=enabled" json:"enabled,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SwitchState) Reset()                    { *m = SwitchState{} }
func (m *SwitchState) String() string            { return proto.CompactTextString(m) }
func (*SwitchState) ProtoMessage()               {}
func (*SwitchState) Descriptor() ([]byte, []int) { return fileDescriptor19, []int{11} }

func (m *SwitchState) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func init() {
	proto.RegisterType((*MetaRegionServer)(nil), "pb.MetaRegionServer")
	proto.RegisterType((*Master)(nil), "pb.Master")
	proto.RegisterType((*ClusterUp)(nil), "pb.ClusterUp")
	proto.RegisterType((*RegionTransition)(nil), "pb.RegionTransition")
	proto.RegisterType((*SplitLogTask)(nil), "pb.SplitLogTask")
	proto.RegisterType((*Table)(nil), "pb.Table")
	proto.RegisterType((*ReplicationPeer)(nil), "pb.ReplicationPeer")
	proto.RegisterType((*ReplicationState)(nil), "pb.ReplicationState")
	proto.RegisterType((*ReplicationHLogPosition)(nil), "pb.ReplicationHLogPosition")
	proto.RegisterType((*ReplicationLock)(nil), "pb.ReplicationLock")
	proto.RegisterType((*TableLock)(nil), "pb.TableLock")
	proto.RegisterType((*SwitchState)(nil), "pb.SwitchState")
	proto.RegisterEnum("pb.SplitLogTask_State", SplitLogTask_State_name, SplitLogTask_State_value)
	proto.RegisterEnum("pb.SplitLogTask_RecoveryMode", SplitLogTask_RecoveryMode_name, SplitLogTask_RecoveryMode_value)
	proto.RegisterEnum("pb.Table_State", Table_State_name, Table_State_value)
	proto.RegisterEnum("pb.ReplicationState_State", ReplicationState_State_name, ReplicationState_State_value)
}

func init() { proto.RegisterFile("ZooKeeper.proto", fileDescriptor19) }

var fileDescriptor19 = []byte{
	// 907 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0xef, 0x6e, 0xe2, 0x46,
	0x10, 0x8f, 0x0d, 0x49, 0xf0, 0x10, 0x12, 0xba, 0x55, 0x7b, 0x56, 0xaa, 0x6b, 0x91, 0x3f, 0xa4,
	0xe8, 0x7a, 0xa5, 0x27, 0xa4, 0x4a, 0xa7, 0x7c, 0x68, 0x15, 0x02, 0x4a, 0xd0, 0x11, 0x40, 0x6b,
	0xd2, 0x53, 0xfb, 0xc5, 0x5a, 0xec, 0x09, 0x58, 0x01, 0xef, 0x6a, 0xbd, 0xe4, 0xca, 0x1b, 0xdc,
	0x63, 0xf4, 0x09, 0xfa, 0x1a, 0xfd, 0xd4, 0x47, 0xe8, 0xbb, 0x54, 0xbb, 0x0b, 0x04, 0xd2, 0x9e,
	0xf2, 0xc5, 0xda, 0xf9, 0xcd, 0x9f, 0xdf, 0xec, 0xec, 0xcc, 0x18, 0x4e, 0x7e, 0xe3, 0xfc, 0x1d,
	0xa2, 0x40, 0xd9, 0x10, 0x92, 0x2b, 0x4e, 0x5c, 0x31, 0x3e, 0x2d, 0x5f, 0xb7, 0x58, 0x8e, 0x16,
	0x38, 0xfd, 0xfc, 0x72, 0xb6, 0xc8, 0x15, 0xca, 0x50, 0x31, 0xb5, 0xc8, 0x2d, 0x18, 0x7c, 0x74,
	0xa0, 0x7a, 0x83, 0x8a, 0x51, 0x9c, 0xa4, 0x3c, 0x0b, 0x51, 0x3e, 0xa0, 0x24, 0x67, 0x70, 0x90,
	0x9b, 0x93, 0xef, 0xd4, 0xdc, 0x7a, 0xb9, 0x79, 0xdc, 0x10, 0xe3, 0x86, 0xd5, 0xf5, 0xd9, 0x1c,
	0xe9, 0x4a, 0x4b, 0xbe, 0x81, 0xb2, 0x14, 0x71, 0xf4, 0x80, 0x32, 0x4f, 0x79, 0xe6, 0xbb, 0x35,
	0xa7, 0x5e, 0xa1, 0x20, 0x45, 0xfc, 0x8b, 0x45, 0xc8, 0x77, 0xb0, 0x9f, 0x2b, 0xa6, 0xd0, 0x2f,
	0xd4, 0x9c, 0xfa, 0x71, 0xf3, 0x0b, 0x1d, 0x67, 0xc5, 0xa4, 0xe1, 0x86, 0xf9, 0x52, 0x6b, 0x13,
	0x64, 0x70, 0x70, 0xc3, 0x74, 0x82, 0x9a, 0x7f, 0x6e, 0x4e, 0x9f, 0xe2, 0xb7, 0xda, 0xe7, 0xf9,
	0xbf, 0x02, 0x2f, 0xcd, 0xee, 0x78, 0x24, 0xb8, 0x54, 0x26, 0x87, 0x0a, 0x2d, 0x69, 0x60, 0xc8,
	0xa5, 0x0a, 0x5e, 0x81, 0xb7, 0xaa, 0xc8, 0xad, 0x20, 0x2f, 0x01, 0x72, 0xc5, 0xa4, 0x8a, 0x12,
	0x9d, 0xae, 0xa6, 0xf5, 0xa8, 0x67, 0x90, 0xb6, 0xce, 0xed, 0x2f, 0x07, 0xaa, 0x36, 0xf1, 0x91,
	0x64, 0x59, 0x9e, 0x2a, 0x1d, 0xfd, 0x0c, 0x4e, 0xf0, 0x01, 0x33, 0x15, 0xa9, 0xa5, 0xc0, 0x28,
	0xe6, 0x89, 0x75, 0xac, 0xd0, 0x8a, 0x81, 0x47, 0x4b, 0x81, 0x97, 0x3c, 0x41, 0x93, 0xa6, 0xf1,
	0x8d, 0x32, 0x36, 0x47, 0xdf, 0xad, 0xb9, 0xf5, 0x23, 0x0a, 0x16, 0xd2, 0xf7, 0xd1, 0x06, 0xb1,
	0x44, 0xa6, 0x30, 0x52, 0xe9, 0x5c, 0x17, 0xcb, 0xad, 0x17, 0x29, 0x58, 0x68, 0x94, 0xce, 0x91,
	0xfc, 0x00, 0x65, 0x5b, 0x72, 0x1b, 0xa1, 0xf8, 0xbf, 0x55, 0x81, 0x7c, 0x73, 0x26, 0x3e, 0x1c,
	0x0a, 0xb6, 0x9c, 0x71, 0x96, 0xf8, 0xfb, 0x35, 0xa7, 0x7e, 0x44, 0xd7, 0x62, 0xf0, 0xa7, 0x0b,
	0x47, 0xa1, 0x98, 0xa5, 0xaa, 0xc7, 0x27, 0x23, 0x96, 0xdf, 0x93, 0xd7, 0xeb, 0x37, 0xd2, 0xb9,
	0x1f, 0x37, 0xbf, 0x34, 0x51, 0xb7, 0x0c, 0x76, 0x1e, 0xe9, 0x69, 0x26, 0xee, 0xb3, 0x99, 0x9c,
	0x43, 0x71, 0xae, 0x2b, 0x63, 0x3b, 0xe0, 0xe5, 0x7f, 0xa2, 0x53, 0x8c, 0xf9, 0x03, 0xca, 0xe5,
	0x0d, 0x4f, 0xf0, 0xfc, 0xf0, 0xb6, 0xff, 0xae, 0x3f, 0x78, 0xdf, 0xa7, 0xc6, 0x27, 0xb8, 0x84,
	0x7d, 0x43, 0x4e, 0x8e, 0x01, 0x6e, 0xfb, 0x17, 0x61, 0xd8, 0xbd, 0xea, 0x77, 0xda, 0xd5, 0x3d,
	0xe2, 0xc1, 0xfe, 0xe0, 0xbd, 0x3e, 0x3a, 0xe4, 0x08, 0x4a, 0xb4, 0xb3, 0x52, 0xb8, 0xa4, 0x04,
	0xc5, 0xf6, 0xa0, 0xdf, 0xa9, 0x16, 0xc8, 0x21, 0x14, 0x3a, 0x94, 0x56, 0x8b, 0xc1, 0x4f, 0x70,
	0xb4, 0xcd, 0x41, 0xca, 0xb0, 0x66, 0xa9, 0xee, 0x91, 0xcf, 0xa0, 0xd2, 0x1b, 0x5c, 0x45, 0xe1,
	0xb0, 0xd7, 0x1d, 0x8d, 0xba, 0xfd, 0xab, 0xaa, 0xa3, 0xb9, 0x34, 0x44, 0x3b, 0xc3, 0xde, 0xc5,
	0xaf, 0x55, 0x37, 0xf8, 0x1d, 0xf6, 0x47, 0x6c, 0x3c, 0x43, 0xd2, 0xd8, 0x2d, 0xd4, 0x89, 0xbe,
	0x8a, 0xd1, 0xd8, 0x0a, 0x9d, 0x1f, 0x76, 0xfa, 0x17, 0xad, 0x5e, 0xa7, 0xbd, 0xee, 0xe7, 0x9f,
	0xd7, 0xd9, 0x97, 0x61, 0xad, 0xaa, 0xee, 0xe9, 0x7c, 0xdb, 0xdd, 0xd0, 0x4a, 0x0e, 0xa9, 0x80,
	0x67, 0x25, 0xcd, 0xed, 0x6a, 0xa5, 0xb1, 0xd4, 0x52, 0x21, 0xf8, 0xdb, 0x81, 0x13, 0x8a, 0x62,
	0x96, 0xc6, 0x4c, 0xf7, 0xdb, 0x10, 0x51, 0x92, 0xaf, 0x01, 0x62, 0xdb, 0xb4, 0xf7, 0xb8, 0x5c,
	0xf5, 0xe9, 0x16, 0x42, 0xde, 0xc2, 0x0b, 0xf9, 0xe8, 0xd2, 0xc9, 0x12, 0xc1, 0xd3, 0x4c, 0x75,
	0xe7, 0x62, 0x66, 0xc6, 0xc3, 0xa3, 0x9f, 0x52, 0x93, 0x33, 0x28, 0x26, 0x4c, 0x31, 0xbf, 0x50,
	0x2b, 0xd4, 0xcb, 0x4d, 0xa2, 0x6f, 0xd7, 0x5a, 0x2a, 0xcc, 0xcd, 0x67, 0xc8, 0x52, 0x49, 0x8d,
	0x9e, 0xbc, 0x85, 0x4a, 0xcc, 0xb3, 0xbb, 0x74, 0xb2, 0x90, 0x26, 0x88, 0x5f, 0x7c, 0x74, 0xd0,
	0x2f, 0x1e, 0x2a, 0x99, 0x66, 0x13, 0xe3, 0xb0, 0x6b, 0x18, 0x4c, 0xf5, 0x0c, 0x6d, 0xc8, 0x6d,
	0x6d, 0xde, 0xec, 0x16, 0xf5, 0xd4, 0x6e, 0x88, 0x5d, 0xa3, 0xdd, 0x35, 0x11, 0x3c, 0x5f, 0xd6,
	0xe0, 0x47, 0x78, 0xb1, 0x15, 0xe4, 0xba, 0xc7, 0x27, 0x43, 0xbe, 0x1a, 0xda, 0x53, 0x28, 0x89,
	0xd5, 0xd9, 0x70, 0x16, 0xe8, 0x46, 0x0e, 0xde, 0xec, 0xd4, 0xbb, 0xc7, 0xe3, 0x7b, 0xbd, 0x17,
	0x66, 0x3c, 0xbe, 0x8f, 0xf8, 0x87, 0x6c, 0xb5, 0x8e, 0x3c, 0xea, 0x69, 0x64, 0xa0, 0x81, 0xe0,
	0x1f, 0x07, 0x3c, 0xd3, 0x03, 0xc6, 0xf8, 0x35, 0x80, 0xd2, 0x82, 0x9d, 0x0d, 0xa7, 0xe6, 0xd4,
	0xcb, 0xcd, 0xca, 0xa6, 0x4d, 0xcc, 0x68, 0x78, 0x6a, 0x7d, 0x24, 0xdf, 0xef, 0x84, 0x76, 0x8d,
	0xf5, 0xd3, 0x49, 0x7a, 0xa4, 0xd2, 0xbb, 0x4c, 0x4d, 0x25, 0xb2, 0x24, 0x4a, 0x13, 0x33, 0x4d,
	0x05, 0x5a, 0xb2, 0x40, 0x37, 0x31, 0x8b, 0x2e, 0x8f, 0xf2, 0x29, 0x93, 0x98, 0xf8, 0xc5, 0x9a,
	0x53, 0x2f, 0xd1, 0x52, 0x9a, 0x87, 0x46, 0x36, 0xcb, 0x60, 0x21, 0x05, 0xcf, 0xd1, 0x2c, 0x03,
	0x8f, 0xae, 0xc5, 0xa7, 0x8b, 0xe7, 0xc0, 0x44, 0xdd, 0x5a, 0x3c, 0xc1, 0xb7, 0x50, 0x0e, 0x3f,
	0xa4, 0x2a, 0x9e, 0xda, 0x92, 0xfb, 0x70, 0x88, 0x99, 0xbe, 0x40, 0x62, 0x6e, 0x57, 0xa2, 0x6b,
	0xb1, 0xd5, 0x81, 0x57, 0x5c, 0x4e, 0x1a, 0x4c, 0xb0, 0x78, 0x8a, 0x8d, 0x29, 0x4b, 0x38, 0x17,
	0x8d, 0xe9, 0x78, 0xf3, 0xf7, 0x19, 0x2f, 0xee, 0x1a, 0x13, 0xcc, 0x50, 0x32, 0x85, 0x49, 0xeb,
	0xf1, 0x67, 0x35, 0xd4, 0xca, 0xfc, 0xda, 0xf9, 0xe8, 0x38, 0x7f, 0x38, 0xce, 0xbf, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x48, 0xdb, 0x93, 0x4c, 0xc6, 0x06, 0x00, 0x00,
}
